\hypertarget{md__r_e_a_d_m_e_autotoc_md1}{}\doxysection{Over\+View}\label{md__r_e_a_d_m_e_autotoc_md1}
\hypertarget{md__r_e_a_d_m_e_autotoc_md2}{}\doxysubsection{the robot movement}\label{md__r_e_a_d_m_e_autotoc_md2}

\begin{DoxyItemize}
\item the robot moves to the random position when user demand the robot to move.
\begin{DoxyItemize}
\item when the user type 1 in the shell, the robot starts to move
\item when the user type 0 in the shell, the robot try to stop (in the action branch, the robot stops immediately. Otherwise, the robot can be stopped only when it reaches a target)
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md3}{}\doxysubsection{nodes}\label{md__r_e_a_d_m_e_autotoc_md3}
There are four main nodes


\begin{DoxyItemize}
\item Goto\+Point node
\begin{DoxyItemize}
\item drive the robot towards the random position in space (x,y) and with a certain angle (theta)
\end{DoxyItemize}
\item User interface node
\begin{DoxyItemize}
\item receive the user request
\item ask the state\+\_\+machine to send the command to the robot
\end{DoxyItemize}
\item Position server node
\begin{DoxyItemize}
\item reply with random values for x, y, and theta, where x and y should be limited between some min and max values
\end{DoxyItemize}
\item State machine node
\begin{DoxyItemize}
\item give the possibility to start or stop the robot behaviour when the user requests
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md4}{}\doxysubsection{Requirements of assignment}\label{md__r_e_a_d_m_e_autotoc_md4}
\hypertarget{md__r_e_a_d_m_e_autotoc_md5}{}\doxysubsubsection{Q1) Action branch}\label{md__r_e_a_d_m_e_autotoc_md5}

\begin{DoxyItemize}
\item state machine node should now implement mechanisms for possibly canceling the goal, when user type stop (0) command in the shell
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md6}{}\doxysubsubsection{Q2) R\+O\+S2 branch}\label{md__r_e_a_d_m_e_autotoc_md6}

\begin{DoxyItemize}
\item cpp nodes are written for R\+OS as components
\item by using the ros1\+\_\+bridge, they can be interfaces with the R\+OS nodes and with simulation in Gazebo.
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md7}{}\doxysubsubsection{Q3) Main branch}\label{md__r_e_a_d_m_e_autotoc_md7}

\begin{DoxyItemize}
\item use Vrep in stead of Gazebo
\item Vrep communicate with R\+OS (not R\+O\+S2)
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md8}{}\doxysubsection{Description of the content of the package}\label{md__r_e_a_d_m_e_autotoc_md8}

\begin{DoxyItemize}
\item \mbox{\hyperlink{go__to__point_8py}{go\+\_\+to\+\_\+point.\+py}}
\begin{DoxyItemize}
\item receive the goal position (/go\+\_\+to\+\_\+point)
\item control the velocity depending on the position
\item send the velocity (/cmd\+\_\+vel)
\end{DoxyItemize}
\item \mbox{\hyperlink{user__interface_8py}{user\+\_\+interface.\+py}}
\begin{DoxyItemize}
\item user interface (command line)
\item when the user put \char`\"{}start\char`\"{}, the robot starts to move
\item when the user put \char`\"{}stop\char`\"{}, the robot stops
\end{DoxyItemize}
\item \mbox{\hyperlink{position__service_8cpp}{position\+\_\+service.\+cpp}}
\begin{DoxyItemize}
\item when service is received from state machine, it returns the random position
\end{DoxyItemize}
\item \mbox{\hyperlink{state__machine_8cpp}{state\+\_\+machine.\+cpp}}
\begin{DoxyItemize}
\item when service is recived from user interface, it sends the service to position\+\_\+service.
\item it sends the random position as the goal to \mbox{\hyperlink{namespacego__to__point}{go\+\_\+to\+\_\+point}}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md9}{}\doxysubsubsection{Topic}\label{md__r_e_a_d_m_e_autotoc_md9}

\begin{DoxyItemize}
\item /cmd\+\_\+vel
\begin{DoxyItemize}
\item Type\+: gemetry\+\_\+msgs/\+Twist
\item Publisher Node\+: /go\+\_\+to\+\_\+point
\item Subscriber Node\+: /gazebo or /vrep
\end{DoxyItemize}
\item /odom
\begin{DoxyItemize}
\item Type\+: nav\+\_\+msgs/\+Odometry
\item Publisher Node\+: /gazebo or /vrep
\item Subscriber Node\+: /go\+\_\+to\+\_\+point
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md10}{}\doxysubsubsection{Service}\label{md__r_e_a_d_m_e_autotoc_md10}

\begin{DoxyItemize}
\item /go\+\_\+to\+\_\+point
\begin{DoxyItemize}
\item Client Node\+: \mbox{\hyperlink{namespacego__to__point}{go\+\_\+to\+\_\+point}}
\item Server Node\+: state\+\_\+machine
\item Type \+: Position
\end{DoxyItemize}
\item /position\+\_\+server
\begin{DoxyItemize}
\item Client Node\+: state\+\_\+machine
\item Server Node\+: random\+\_\+position\+\_\+server
\item Type\+: Random\+Position
\end{DoxyItemize}
\item /user\+\_\+interface
\begin{DoxyItemize}
\item Client Node\+: \mbox{\hyperlink{namespaceuser__interface}{user\+\_\+interface}}
\item Server Node\+: state\+\_\+machine
\item Type \+: Command
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md11}{}\doxysubsubsection{custom service}\label{md__r_e_a_d_m_e_autotoc_md11}

\begin{DoxyItemize}
\item rt2\+\_\+assignment1/\+Random\+Position
\begin{DoxyItemize}
\item request
\end{DoxyItemize}
\item float32 x\+\_\+max
\begin{DoxyItemize}
\item float32 x\+\_\+min
\item float32 y\+\_\+max
\item float32 y\+\_\+min
\end{DoxyItemize}
\end{DoxyItemize}

response
\begin{DoxyItemize}
\item float32 x
\begin{DoxyItemize}
\item float32 y
\item float32 theta
\end{DoxyItemize}
\end{DoxyItemize}

rt2\+\_\+assignment1/\+Position
\begin{DoxyItemize}
\item request
\begin{DoxyItemize}
\item float32 x
\item float32 y
\item float32 theta
\end{DoxyItemize}
\end{DoxyItemize}

response
\begin{DoxyItemize}
\item bool ok
\end{DoxyItemize}

rt2\+\_\+assignment1/\+Position
\begin{DoxyItemize}
\item request
\begin{DoxyItemize}
\item string command
\end{DoxyItemize}
\item response
\begin{DoxyItemize}
\item bool ok
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md12}{}\doxysection{Q1) Action branch}\label{md__r_e_a_d_m_e_autotoc_md12}
please look at \href{https://github.com/n-shintaro/rt2_assignment1/tree/action}{\texttt{ Readme of action branch}}\hypertarget{md__r_e_a_d_m_e_autotoc_md13}{}\doxysection{Q2) R\+O\+S2 branch}\label{md__r_e_a_d_m_e_autotoc_md13}
please look at \href{https://github.com/n-shintaro/rt2_assignment1/tree/ros2}{\texttt{ Readme of action branch}}\hypertarget{md__r_e_a_d_m_e_autotoc_md14}{}\doxysection{Q3) main branch}\label{md__r_e_a_d_m_e_autotoc_md14}
\hypertarget{md__r_e_a_d_m_e_autotoc_md15}{}\doxysubsection{Dependencies}\label{md__r_e_a_d_m_e_autotoc_md15}
This software is built on the Robotic Operating System (\mbox{[}R\+OS\mbox{]}), which needs to be install first and create the workspace.


\begin{DoxyItemize}
\item Ubuntu 20.\+04
\item R\+OS noetic
\item Coppelia\+Sim V 4.\+2.\+0
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md16}{}\doxysubsection{Setting of Coppelia\+Sim}\label{md__r_e_a_d_m_e_autotoc_md16}
\hypertarget{md__r_e_a_d_m_e_autotoc_md17}{}\doxysubsubsection{download $<$a href=\char`\"{}http\+://www.\+coppeliarobotics.\+com/downloads.\+html\char`\"{}$>$here$<$/a$>$}\label{md__r_e_a_d_m_e_autotoc_md17}
\hypertarget{md__r_e_a_d_m_e_autotoc_md18}{}\doxysubsubsection{R\+O\+S integration}\label{md__r_e_a_d_m_e_autotoc_md18}
Vrep should be already6 integrated with R\+OS. You just need to launch the R\+OS master before running the V-\/\+R\+EP (Coppelia\+Sim) software.

If there is any problem in building the plugin, you will need to recompile it by yourself\+: you can download it from here


\begin{DoxyCode}{0}
\DoxyCodeLine{\# install xsltproc}
\DoxyCodeLine{Run apt-\/get install xsltproc}
\DoxyCodeLine{}
\DoxyCodeLine{\# install xmlschema}
\DoxyCodeLine{pip3 install xmlschema}
\DoxyCodeLine{}
\DoxyCodeLine{git clone https://github.com/CoppeliaRobotics/simExtROS.git}
\end{DoxyCode}


In order to build the packages, navigate to the catkin\+\_\+ws folder and type\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\#\#\# it is better to write it in .bashrc}
\DoxyCodeLine{export COPPELIASIM\_ROOT\_DIR=\string~/path/to/coppeliaSim/folder}
\DoxyCodeLine{catkin\_make -\/-\/cmake-\/args -\/DCMAKE\_BUILD\_TYPE=Release}
\end{DoxyCode}


Vrep should be executed when the R\+OS master is already running


\begin{DoxyCode}{0}
\DoxyCodeLine{roscore}
\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{cd /install folder of Coppeliasim}
\DoxyCodeLine{./coppeliasim.sh}
\end{DoxyCode}


Copy the devel/lib/libsim\+Ext\+R\+O\+S.\+so file to the Coppelia\+Sim installation folder.\hypertarget{md__r_e_a_d_m_e_autotoc_md19}{}\doxysubsection{Compiling and Running}\label{md__r_e_a_d_m_e_autotoc_md19}
\hypertarget{md__r_e_a_d_m_e_autotoc_md20}{}\doxysubsubsection{first terminal}\label{md__r_e_a_d_m_e_autotoc_md20}
Build catkin\+\_\+workspace


\begin{DoxyCode}{0}
\DoxyCodeLine{cd cakin\_workspace}
\DoxyCodeLine{catkin\_make}
\DoxyCodeLine{roscore}
\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md21}{}\doxysubsubsection{second terminal}\label{md__r_e_a_d_m_e_autotoc_md21}
start Coppelia\+Sim


\begin{DoxyCode}{0}
\DoxyCodeLine{cd /install folder of Coppeliasim}
\DoxyCodeLine{./coppeliasim.sh}
\end{DoxyCode}


file-\/$>$open scene-\/$>$go to the vrep folder of rt2\+\_\+assignment package-\/$>$ pioneer\+R\+O\+S\+\_\+rt2.\+ttt

and run the simulator\hypertarget{md__r_e_a_d_m_e_autotoc_md22}{}\doxysubsubsection{third terminal}\label{md__r_e_a_d_m_e_autotoc_md22}
launch all the nodes without gazebo simulator


\begin{DoxyCode}{0}
\DoxyCodeLine{roslaunch rt2\_assignment1 sim\_vrep.launch}
\end{DoxyCode}
 